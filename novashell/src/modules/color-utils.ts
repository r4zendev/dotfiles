import Gio from "gi://Gio?version=2.0";
import GLib from "gi://GLib?version=2.0";

import { writeFileAsync } from "ags/file";
import { execAsync } from "ags/process";

export type ColorData = {
	name?: string;
	wallpaper?: string;
	accent?: string;
	special: {
		background: string;
		foreground: string;
		cursor: string;
	};
	colors: {
		color0: string;
		color1: string;
		color2: string;
		color3: string;
		color4: string;
		color5: string;
		color6: string;
		color7: string;
		color8: string;
		color9: string;
		color10: string;
		color11: string;
		color12: string;
		color13: string;
		color14: string;
		color15: string;
	};
};

const stripHash = (hex: string) => hex.replace(/^#/, "");

export function reloadTmux(): void {
	const colorsPath = `${GLib.get_user_cache_dir()}/novashell/tmux-colors.conf`;
	execAsync(["tmux", "source-file", colorsPath])
		.then(() => {
			execAsync([
				"bash", "-c",
				"tmux list-clients -F '#{client_name}' | while read c; do tmux refresh-client -t \"$c\" -S; done",
			]).catch(() => {});
			console.log("ColorUtils: Reloaded tmux colors");
		})
		.catch(() => {});
}

const NOVASHELL_TO_NVIM_THEME: Record<string, string> = {
	"Tokyo Night": "Tokyo Night",
	Everforest: "Everforest",
	"Catppuccin Mocha": "Catppuccin",
};

export function reloadNeovim(themeName?: string): void {
	const nvimTheme = (themeName && NOVASHELL_TO_NVIM_THEME[themeName]) || "System (pywal)";
	const escaped = nvimTheme.replace(/'/g, "\\'");
	execAsync([
		"bash", "-c",
		`for sock in /run/user/1000/nvim.*.0; do [ -e "$sock" ] && nvim --server "$sock" --remote-send ':lua require("core.colorscheme").apply("${escaped}")<CR>' 2>/dev/null; done`,
	])
		.then(() => console.log(`ColorUtils: Reloaded neovim instances (theme=${nvimTheme})`))
		.catch(() => {});
}

export function reloadFish(): void {
	const walCachePath = `${GLib.get_user_cache_dir()}/wal/colors.fish`;
	execAsync(["fish", "-c", `source ${walCachePath}`])
		.then(() => console.log("ColorUtils: Reloaded fish colors"))
		.catch(() => {});
}

/** Broadcast terminal color changes via OSC escape sequences to all PTYs.
 * Uses Python (same approach as pywal) for reliable escape byte writing. */
export function broadcastTerminalColors(data: ColorData): void {
	const parts: string[] = [];

	for (let i = 0; i <= 15; i++) {
		const key = `color${i}` as keyof typeof data.colors;
		if (data.colors[key]) parts.push(`\\033]4;${i};${data.colors[key]}\\007`);
	}

	parts.push(`\\033]10;${data.special.foreground}\\007`);
	parts.push(`\\033]12;${data.special.cursor}\\007`);

	const seq = parts.join("");

	execAsync([
		"python3", "-c",
		`import glob,os\nseq="${seq}"\nseq=seq.encode().decode("unicode_escape")\ncount=0\nfor t in glob.glob("/dev/pts/[0-9]*"):\n try:\n  with open(t,"w") as f: f.write(seq); count+=1\n except: pass\nprint(count)`,
	])
		.then((out) => console.log(`ColorUtils: Broadcast to ${out.trim()} PTYs`))
		.catch((e) => console.error(`ColorUtils: Broadcast failed: ${e}`));
}

export async function generateTmuxColors(data: ColorData): Promise<void> {
	const colors = data.colors;
	const special = data.special;
	const accent = data.accent || colors.color4;
	const surface = adjustLightness(special.background, 15);

	const tmuxColors = `# Generated by novashell
set -g pane-border-style "fg=${colors.color8}"
set -g pane-active-border-style "fg=${accent}"
set -g pane-border-lines single
set -g pane-border-indicators off
set -g message-style "fg=${special.foreground},bg=default"
set -g window-status-format "#[fg=${special.background},bg=${colors.color8}] #I #[fg=${special.foreground},bg=${surface}] #{b:pane_current_path} "
set -g window-status-current-format "#[fg=${special.background},bg=${accent}] #I #[fg=${special.foreground},bg=${surface}] #{b:pane_current_path} "
set-window-option -g window-status-separator " "
`;

	const cacheDir = `${GLib.get_user_cache_dir()}/novashell`;
	const cacheDirFile = Gio.File.new_for_path(cacheDir);
	if (!cacheDirFile.query_exists(null)) {
		cacheDirFile.make_directory_with_parents(null);
	}

	await writeFileAsync(`${cacheDir}/tmux-colors.conf`, tmuxColors).catch(
		(e) => {
			console.error(`ColorUtils: Could not write tmux colors: ${e}`);
		},
	);
}

export async function generateFishColors(data: ColorData): Promise<void> {
	const c = data.colors;
	const s = data.special;

	const fishColors = `# Generated by novashell - Theme: ${data.name || "pywal"}
# Uses universal variables (-U) so changes propagate to all running fish sessions

set -U fish_color_normal ${stripHash(s.foreground)}
set -U fish_color_command ${stripHash(c.color4)}
set -U fish_color_keyword ${stripHash(c.color5)}
set -U fish_color_quote ${stripHash(c.color2)}
set -U fish_color_redirection ${stripHash(c.color6)}
set -U fish_color_end ${stripHash(c.color5)}
set -U fish_color_error ${stripHash(c.color1)}
set -U fish_color_param ${stripHash(c.color6)}
set -U fish_color_comment ${stripHash(c.color8)}
set -U fish_color_selection --background=${stripHash(c.color8)}
set -U fish_color_search_match --background=${stripHash(c.color8)}
set -U fish_color_operator ${stripHash(c.color6)}
set -U fish_color_escape ${stripHash(c.color5)}
set -U fish_color_autosuggestion ${stripHash(c.color8)}
set -U fish_color_cwd ${stripHash(c.color4)}
set -U fish_color_user ${stripHash(c.color2)}
set -U fish_color_host ${stripHash(c.color4)}
set -U fish_color_host_remote ${stripHash(c.color3)}
set -U fish_color_cancel ${stripHash(c.color1)}

set -U fish_pager_color_progress ${stripHash(c.color8)}
set -U fish_pager_color_prefix ${stripHash(c.color4)}
set -U fish_pager_color_completion ${stripHash(s.foreground)}
set -U fish_pager_color_description ${stripHash(c.color8)}
`;

	const walCachePath = `${GLib.get_user_cache_dir()}/wal/colors.fish`;
	await writeFileAsync(walCachePath, fishColors).catch((e) => {
		console.error(`ColorUtils: Could not write fish colors: ${e}`);
	});
}

export function updateHyprlandColors(data: ColorData): void {
	const accent = (data.accent || data.colors.color4).replace(/^#/, "");
	const inactive = data.colors.color8.replace(/^#/, "");

	execAsync(`hyprctl keyword general:col.active_border "rgb(${accent})"`).catch(
		() => {
			/* Hyprland might not be running */
		},
	);

	execAsync(
		`hyprctl keyword general:col.inactive_border "rgb(${inactive})"`,
	).catch(() => {
		/* Hyprland might not be running */
	});
}

/** Adjust lightness of a hex color by a fixed amount (-255 to +255) */
function adjustLightness(hex: string, amount: number): string {
	const h = hex.replace(/^#/, "");
	const r = Math.max(
		0,
		Math.min(255, parseInt(h.substring(0, 2), 16) + amount),
	);
	const g = Math.max(
		0,
		Math.min(255, parseInt(h.substring(2, 4), 16) + amount),
	);
	const b = Math.max(
		0,
		Math.min(255, parseInt(h.substring(4, 6), 16) + amount),
	);
	return `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
}

export async function updateGhosttyColors(data: ColorData): Promise<void> {
	const colors = data.colors;
	const special = data.special;

	const lines: string[] = [];

	for (let i = 0; i <= 15; i++) {
		const colorKey = `color${i}` as keyof typeof colors;
		if (colors[colorKey]) {
			lines.push(`palette = ${i}=${colors[colorKey]}`);
		}
	}

	lines.push(``);
	lines.push(`background = ${special.background}`);
	lines.push(`foreground = ${special.foreground}`);
	lines.push(`cursor-color = ${special.cursor}`);
	lines.push(`selection-background = ${colors.color8}`);
	lines.push(`selection-foreground = ${special.foreground}`);

	const content = lines.join("\n") + "\n";
	const ghosttyColorsPath = `${GLib.get_user_config_dir()}/ghostty/colors`;

	// Write to temp file, then `cp` to target. `cp` writes in-place (same inode),
	// which fires IN_MODIFY + IN_CLOSE_WRITE so Ghostty's inotify watcher detects changes.
	// writeFileAsync / Gio.File.replace use atomic temp+rename which invalidates the watch.
	const tmpPath = `${GLib.get_tmp_dir()}/novashell-ghostty-colors`;
	await writeFileAsync(tmpPath, content).catch((e: Error) => {
		console.error(`ColorUtils: Failed to write ghostty temp: ${e.message}`);
	});
	await execAsync(["cp", "--", tmpPath, ghosttyColorsPath]).catch((e: Error) => {
		console.error(`ColorUtils: Failed to cp ghostty colors: ${e.message}`);
	});

	reloadGhostty();
	console.log(`ColorUtils: Ghostty colors written (bg=${special.background})`);
}

function reloadGhostty(): void {
	execAsync([
		"bash", "-c",
		`hyprctl clients -j | jq -r '.[] | select(.class == "com.mitchellh.ghostty") | .address' | while read addr; do hyprctl dispatch sendshortcut "CTRL SHIFT, comma, address:$addr" 2>/dev/null; done`,
	])
		.then(() => console.log("ColorUtils: Ghostty config reloaded"))
		.catch(() => {});
}

export async function updateBtopColors(data: ColorData): Promise<void> {
	const c = data.colors;
	const s = data.special;

	const btopTheme = `# Generated by novashell
# Wallpaper: ${data.wallpaper}

# Main background, empty for terminal default
theme[main_bg]=""

# Main text color
theme[main_fg]="${s.foreground}"

# Title color for boxes
theme[title]="${s.foreground}"

# Highlight color for keyboard shortcuts
theme[hi_fg]="${c.color4}"

# Background color of selected item in processes box
theme[selected_bg]="${c.color4}"

# Foreground color of selected item in processes box
theme[selected_fg]="${s.background}"

# Color of inactive/disabled text
theme[inactive_fg]="${c.color8}"

# Color of text appearing on top of graphs
theme[graph_text]="${s.foreground}"

# Background color of the percentage meters
theme[meter_bg]="${c.color8}"

# Misc colors for processes box including mini cpu graphs
theme[proc_misc]="${c.color5}"

# Cpu box outline color
theme[cpu_box]="${c.color4}"

# Memory/disks box outline color
theme[mem_box]="${c.color2}"

# Net up/down box outline color
theme[net_box]="${c.color1}"

# Processes box outline color
theme[proc_box]="${c.color6}"

# Box divider line and small boxes line color
theme[div_line]="${c.color8}"

# Temperature graph colors
theme[temp_start]="${c.color4}"
theme[temp_mid]="${c.color5}"
theme[temp_end]="${c.color1}"

# CPU graph colors
theme[cpu_start]="${c.color4}"
theme[cpu_mid]="${c.color6}"
theme[cpu_end]="${c.color2}"

# Mem/Disk free meter
theme[free_start]="${c.color2}"
theme[free_mid]="${c.color6}"
theme[free_end]="${c.color4}"

# Mem/Disk cached meter
theme[cached_start]="${c.color5}"
theme[cached_mid]="${c.color4}"
theme[cached_end]="${c.color6}"

# Mem/Disk available meter
theme[available_start]="${c.color3}"
theme[available_mid]="${c.color2}"
theme[available_end]="${c.color6}"

# Mem/Disk used meter
theme[used_start]="${c.color1}"
theme[used_mid]="${c.color5}"
theme[used_end]="${c.color4}"

# Download graph colors
theme[download_start]="${c.color4}"
theme[download_mid]="${c.color2}"
theme[download_end]="${c.color6}"

# Upload graph colors
theme[upload_start]="${c.color5}"
theme[upload_mid]="${c.color1}"
theme[upload_end]="${c.color3}"
`;

	const btopThemesDir = Gio.File.new_for_path(
		`${GLib.get_user_config_dir()}/btop/themes`,
	);
	if (!btopThemesDir.query_exists(null)) {
		btopThemesDir.make_directory_with_parents(null);
	}

	const btopThemePath = `${GLib.get_user_config_dir()}/btop/themes/pywal.theme`;
	await writeFileAsync(btopThemePath, btopTheme).catch((e: Error) => {
		console.error(`ColorUtils: Failed to write btop theme: ${e.message}`);
	});
}

export async function updateGtkColors(data: ColorData): Promise<void> {
	const s = data.special;
	const c = data.colors;
	const accent = data.accent || c.color4;

	const viewBg = adjustLightness(s.background, 8);
	const cardBg = adjustLightness(s.background, 13);
	const popoverBg = adjustLightness(s.background, 8);

	const css = `/* Generated by novashell - Theme: ${data.name || "pywal"} */
@define-color accent_bg_color ${accent};
@define-color accent_fg_color ${s.foreground};
@define-color accent_color ${accent};
@define-color destructive_bg_color ${c.color1};
@define-color destructive_fg_color ${s.foreground};
@define-color success_bg_color ${c.color2};
@define-color success_fg_color ${s.foreground};
@define-color warning_bg_color ${c.color3};
@define-color warning_fg_color ${s.background};
@define-color window_bg_color ${s.background};
@define-color window_fg_color ${s.foreground};
@define-color view_bg_color ${viewBg};
@define-color view_fg_color ${s.foreground};
@define-color headerbar_bg_color ${c.color0};
@define-color headerbar_fg_color ${s.foreground};
@define-color card_bg_color ${cardBg};
@define-color card_fg_color ${s.foreground};
@define-color dialog_bg_color ${s.background};
@define-color dialog_fg_color ${s.foreground};
@define-color popover_bg_color ${popoverBg};
@define-color popover_fg_color ${s.foreground};
@define-color sidebar_bg_color ${c.color0};
@define-color sidebar_fg_color ${s.foreground};
`;

	for (const dir of ["gtk-4.0", "gtk-3.0"]) {
		const dirPath = `${GLib.get_user_config_dir()}/${dir}`;
		const dirFile = Gio.File.new_for_path(dirPath);
		if (!dirFile.query_exists(null)) {
			dirFile.make_directory_with_parents(null);
		}
		await writeFileAsync(`${dirPath}/gtk.css`, css).catch((e: Error) => {
			console.error(`ColorUtils: Failed to write ${dir}/gtk.css: ${e.message}`);
		});
	}
}

export async function updateQtColors(data: ColorData): Promise<void> {
	const s = data.special;
	const c = data.colors;
	const accent = data.accent || c.color4;

	const toArgb = (hex: string) => `#ff${stripHash(hex)}`;
	const toArgbAlpha = (hex: string, alpha: string) =>
		`#${alpha}${stripHash(hex)}`;

	const buttonBg = adjustLightness(c.color0, 10);
	const light = adjustLightness(c.color0, 51);
	const midlight = adjustLightness(c.color0, 26);
	const dark = adjustLightness(s.background, -20);
	const altBase = adjustLightness(s.background, 8);

	// 22 values per line: WindowText, Button, Light, Midlight, Dark, Mid, Text,
	// BrightText, ButtonText, Base, Window, Shadow, Highlight, HighlightedText,
	// Link, LinkVisited, AlternateBase, ToolTipBase, ToolTipText, PlaceholderText,
	// Accent, (padding)
	const activeLine = [
		toArgb(s.foreground), // 0  WindowText
		toArgb(buttonBg), // 1  Button
		toArgb(light), // 2  Light
		toArgb(midlight), // 3  Midlight
		toArgb(dark), // 4  Dark
		toArgb(c.color8), // 5  Mid
		toArgb(s.foreground), // 6  Text
		toArgb(s.foreground), // 7  BrightText
		toArgb(s.foreground), // 8  ButtonText
		toArgb(s.background), // 9  Base
		toArgb(s.background), // 10 Window
		"#ff000000", // 11 Shadow
		toArgb(accent), // 12 Highlight
		toArgb(s.foreground), // 13 HighlightedText
		toArgb(accent), // 14 Link
		toArgb(c.color5), // 15 LinkVisited
		toArgb(altBase), // 16 AlternateBase
		toArgb(c.color0), // 17 ToolTipBase
		toArgb(s.foreground), // 18 ToolTipText
		toArgbAlpha(c.color8, "80"), // 19 PlaceholderText
		toArgb(accent), // 20 Accent
		toArgb(s.foreground), // 21 padding
	].join(", ");

	// Inactive: dimmed highlight, dimmed text for WindowText
	const inactiveLine = [
		toArgbAlpha(s.foreground, "bf"), // 0  WindowText (dimmed)
		toArgb(buttonBg), // 1  Button
		toArgb(light), // 2  Light
		toArgb(midlight), // 3  Midlight
		toArgb(dark), // 4  Dark
		toArgb(c.color8), // 5  Mid
		toArgbAlpha(s.foreground, "bf"), // 6  Text (dimmed)
		toArgb(s.foreground), // 7  BrightText
		toArgbAlpha(s.foreground, "bf"), // 8  ButtonText (dimmed)
		toArgb(s.background), // 9  Base
		toArgb(s.background), // 10 Window
		"#ff000000", // 11 Shadow
		toArgb(adjustLightness(accent, -30)), // 12 Highlight (dimmed)
		toArgbAlpha(s.foreground, "bf"), // 13 HighlightedText
		toArgb(accent), // 14 Link
		toArgb(c.color5), // 15 LinkVisited
		toArgb(altBase), // 16 AlternateBase
		toArgb(c.color0), // 17 ToolTipBase
		toArgb(s.foreground), // 18 ToolTipText
		toArgbAlpha(c.color8, "80"), // 19 PlaceholderText
		toArgb(adjustLightness(accent, -30)), // 20 Accent (dimmed)
		toArgb(s.foreground), // 21 padding
	].join(", ");

	// Disabled: even more dimmed
	const disabledLine = [
		toArgbAlpha(s.foreground, "80"), // 0  WindowText
		toArgb(adjustLightness(buttonBg, -10)), // 1  Button
		toArgb(light), // 2  Light
		toArgb(midlight), // 3  Midlight
		toArgb(dark), // 4  Dark
		toArgb(c.color8), // 5  Mid
		toArgbAlpha(s.foreground, "80"), // 6  Text
		toArgb(s.foreground), // 7  BrightText
		toArgbAlpha(s.foreground, "80"), // 8  ButtonText
		toArgb(s.background), // 9  Base
		toArgb(s.background), // 10 Window
		"#ff000000", // 11 Shadow
		toArgb(adjustLightness(s.background, 10)), // 12 Highlight (nearly invisible)
		toArgbAlpha(s.foreground, "80"), // 13 HighlightedText
		toArgb(adjustLightness(accent, -40)), // 14 Link
		toArgb(adjustLightness(c.color5, -40)), // 15 LinkVisited
		toArgb(altBase), // 16 AlternateBase
		toArgb(c.color0), // 17 ToolTipBase
		toArgb(s.foreground), // 18 ToolTipText
		toArgbAlpha(c.color8, "80"), // 19 PlaceholderText
		toArgb(adjustLightness(s.background, 10)), // 20 Accent
		toArgb(s.foreground), // 21 padding
	].join(", ");

	const colorScheme = `[ColorScheme]
active_colors=${activeLine}
inactive_colors=${inactiveLine}
disabled_colors=${disabledLine}
`;

	// Ensure qt6ct colors directory exists
	const colorsDir = `${GLib.get_user_config_dir()}/qt6ct/colors`;
	const colorsDirFile = Gio.File.new_for_path(colorsDir);
	if (!colorsDirFile.query_exists(null)) {
		colorsDirFile.make_directory_with_parents(null);
	}

	const schemePath = `${colorsDir}/pywal.conf`;
	await writeFileAsync(schemePath, colorScheme).catch((e: Error) => {
		console.error(
			`ColorUtils: Failed to write qt6ct color scheme: ${e.message}`,
		);
	});

	// Update qt6ct.conf to point to our color scheme
	const qt6ctConfPath = `${GLib.get_user_config_dir()}/qt6ct/qt6ct.conf`;
	const qt6ctConfFile = Gio.File.new_for_path(qt6ctConfPath);
	if (qt6ctConfFile.query_exists(null)) {
		try {
			const [ok, contents] = qt6ctConfFile.load_contents(null);
			if (ok) {
				let conf = new TextDecoder().decode(contents);
				conf = conf.replace(
					/^color_scheme_path=.*$/m,
					`color_scheme_path=${schemePath}`,
				);
				if (!conf.includes("custom_palette=true")) {
					conf = conf.replace(
						/^\[Appearance\]$/m,
						"[Appearance]\ncustom_palette=true",
					);
				}
				await writeFileAsync(qt6ctConfPath, conf);
			}
		} catch (e) {
			console.error(`ColorUtils: Failed to update qt6ct.conf: ${e}`);
		}
	}
}
